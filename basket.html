<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Woven Basket</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            width: 250px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            font-family: monospace;
            font-size: 12px;
            margin-top: 2px;
        }
        button {
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        select {
            width: 100%;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3>Basket Controls</h3>
        
        <div class="control-group">
            <label for="basketRadius">Basket Radius</label>
            <input type="range" id="basketRadius" min="1" max="4" step="0.1" value="1.6">
            <div class="value-display">1.6</div>
        </div>
        
        <div class="control-group">
            <label for="basketHeight">Basket Height</label>
            <input type="range" id="basketHeight" min="1" max="4" step="0.1" value="2.1">
            <div class="value-display">2.1</div>
        </div>
        
        <div class="control-group">
            <label for="openingRatio">Opening Ratio</label>
            <input type="range" id="openingRatio" min="0.7" max="1" step="0.01" value="0.80">
            <div class="value-display">0.80</div>
        </div>
        
        <div class="control-group">
            <label for="wallThickness">Wall Thickness</label>
            <input type="range" id="wallThickness" min="0.01" max="0.2" step="0.01" value="0.01">
            <div class="value-display">0.01</div>
        </div>
        
        <div class="control-group">
            <label for="bottomCurve">Bottom Curve</label>
            <input type="range" id="bottomCurve" min="0.2" max="1.2" step="0.05" value="1.20">
            <div class="value-display">1.20</div>
        </div>
        
        <div class="control-group">
            <label for="bottomBulge">Bottom Bulge</label>
            <input type="range" id="bottomBulge" min="0" max="1" step="0.05" value="0.2">
            <div class="value-display">0.2</div>
        </div>
        
        <div class="control-group">
            <label for="wallCurvature">Wall Curvature</label>
            <input type="range" id="wallCurvature" min="0" max="1" step="0.05" value="0.3">
            <div class="value-display">0.3</div>
        </div>
        
        <div class="control-group">
            <label for="rimThickness">Rim Thickness</label>
            <input type="range" id="rimThickness" min="0.01" max="0.1" step="0.01" value="0.01">
            <div class="value-display">0.01</div>
        </div>
        
        <button id="resetView">Reset View</button>
    </div>

    <script>
        // Main variables
        let scene, camera, renderer, basketGroup;
        let basketOuter, basketInner, rim, bottom;
        
        // Basket parameter defaults - set to your preferred values
        let params = {
            basketRadius: 1.6,
            basketHeight: 2.2,
            openingRatio: 0.76,
            wallThickness: 0.01,
            bottomCurve: 1.20,
            bottomBulge: 0.50,
            wallCurvature: 0.3,
            rimThickness: 0.01
        };
        
        // Initialize the scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 7;
            camera.position.y = 1;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 0.5, -1);
            scene.add(directionalLight2);
            
            // Create basket
            basketGroup = new THREE.Group();
            scene.add(basketGroup);
            
            createBasket();
            
            // Set up event listeners
            window.addEventListener('resize', onWindowResize);
            setupControls();
            
            // Start animation
            animate();
        }
        
        // Create basket with current parameters
        function createBasket() {
            // Remove previous basket if exists
            if (basketOuter) basketGroup.remove(basketOuter);
            if (basketInner) basketGroup.remove(basketInner);
            if (rim) basketGroup.remove(rim);
            if (bottom) basketGroup.remove(bottom);
            
            // Calculate basket properties
            const basketRadius = params.basketRadius;
            const basketHeight = params.basketHeight;
            const basketOpeningRadius = basketRadius * params.openingRatio;
            
            // Create textures
            const { basketTexture, innerTexture } = createTextures();
            
            // Create basket profile
            const points = [];
            const numPoints = 20;
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                
                if (i <= numPoints * 0.25) {
                    // Bottom curve with adjustable bulge
                    const angle = t * 2 * Math.PI / 2;
                    // Use bottomBulge parameter to control vertical bulge
                    const x = basketRadius * params.bottomCurve * Math.sin(angle);
                    // Adjust the y position based on bottomBulge
                    const normalBulge = basketRadius * params.bottomCurve * (1 - Math.cos(angle));
                    const reducedBulge = normalBulge * params.bottomBulge;
                    const y = -basketHeight/2 + reducedBulge;
                    points.push(new THREE.Vector2(x, y));
                } else {
                    // Side walls with adjustable curvature
                    const prevPoint = points[points.length - 1];
                    const progress = (i - numPoints * 0.25) / (numPoints * 0.75);
                    
                    // Calculate a straight line from previous point to top edge
                    const straightX = prevPoint.x + (basketOpeningRadius - prevPoint.x) * progress;
                    const straightY = prevPoint.y + (basketHeight/2 - prevPoint.y) * progress;
                    
                    // Add curvature to the walls based on the wallCurvature parameter
                    // This creates a gentle inward curve that's stronger in the middle
                    // of the wall and returns to the straight line at the top
                    const curveAmount = params.wallCurvature * (1 - Math.cos(progress * Math.PI)) * 0.5;
                    const curveDirection = basketRadius - basketOpeningRadius;
                    const curveX = straightX - curveAmount * curveDirection;
                    
                    points.push(new THREE.Vector2(curveX, straightY));
                }
            }
            
            // Create geometries with thin walls
            const latheSegments = 60;
            const outerPoints = [...points];
            const innerPoints = points.map(p => new THREE.Vector2(p.x - params.wallThickness, p.y));
            
            const outerGeometry = new THREE.LatheGeometry(outerPoints, latheSegments);
            const innerGeometry = new THREE.LatheGeometry(innerPoints, latheSegments);
            
            // Create materials
            const basketMaterial = new THREE.MeshStandardMaterial({
                map: basketTexture,
                side: THREE.FrontSide,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const innerMaterial = new THREE.MeshStandardMaterial({
                map: innerTexture,
                side: THREE.BackSide,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // Create meshes
            basketOuter = new THREE.Mesh(outerGeometry, basketMaterial);
            basketGroup.add(basketOuter);
            
            basketInner = new THREE.Mesh(innerGeometry, innerMaterial);
            basketGroup.add(basketInner);
            
            // Create bottom
            const bottomGeometry = new THREE.CircleGeometry(points[0].x * 0.95, 32);
            const bottomMaterial = new THREE.MeshStandardMaterial({
                map: innerTexture,
                side: THREE.DoubleSide,
                roughness: 0.9
            });
            
            bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
            bottom.rotation.x = Math.PI / 2;
            bottom.position.y = -basketHeight/2 + 0.02;
            basketGroup.add(bottom);
            
            // Set initial rotation
            basketGroup.rotation.x = -0.2;
        }
        
        // Create textures for basket
        // Default texture creation function
        function createTextures() {
            // Create canvas for outer texture
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 1024;
            
            // Fill with base color (light beige/tan)
            ctx.fillStyle = '#d4bc84';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw detailed weave texture
            const weaveSize = 4;
            ctx.globalAlpha = 1.0;
            
            // Create horizontal strands
            for (let y = 0; y < canvas.height; y += weaveSize * 2) {
                for (let x = 0; x < canvas.width; x += weaveSize) {
                    // Alternate colors for horizontal strands
                    ctx.fillStyle = (Math.floor(y / (weaveSize * 2)) % 2 === 0) ? '#d4c9b4' : '#c9bea9';
                    ctx.fillRect(x, y, weaveSize, weaveSize);
                    
                    // Add subtle shading for dimension
                    ctx.fillStyle = 'rgba(0,0,0,0.1)';
                    ctx.fillRect(x, y + weaveSize - 1, weaveSize, 1);
                }
            }
            
            // Create vertical strands (going over and under)
            for (let x = 0; x < canvas.width; x += weaveSize * 2) {
                for (let y = 0; y < canvas.height; y += weaveSize * 2) {
                    // First vertical strand
                    ctx.fillStyle = (Math.floor(x / (weaveSize * 2)) % 2 === 0) ? '#b5a89e' : '#a89c92';
                    ctx.fillRect(x, y + weaveSize, weaveSize, weaveSize);
                    
                    // Second vertical strand
                    ctx.fillRect(x + weaveSize, y, weaveSize, weaveSize);
                    
                    // Add subtle shading for dimension
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.fillRect(x + weaveSize - 1, y, 1, weaveSize);
                    ctx.fillRect(x + weaveSize * 2 - 1, y + weaveSize, 1, weaveSize);
                }
            }
            
            // Add texture noise for realism
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 80000; i++) {
                const x = Math.floor(Math.random() * canvas.width);
                const y = Math.floor(Math.random() * canvas.height);
                
                ctx.fillStyle = Math.random() > 0.5 ? '#857b70' : '#c9bea9';
                ctx.fillRect(x, y, 1, 1);
            }
            
            ctx.globalAlpha = 1.0;
            
            // Create texture from canvas
            const basketTexture = new THREE.CanvasTexture(canvas);
            basketTexture.wrapS = THREE.RepeatWrapping;
            basketTexture.wrapT = THREE.RepeatWrapping;
            basketTexture.repeat.set(2, 1);
            
            // Create inner texture - similar but darker
            const innerCanvas = document.createElement('canvas');
            const innerCtx = innerCanvas.getContext('2d');
            innerCanvas.width = 1024;
            innerCanvas.height = 1024;
            
            innerCtx.fillStyle = '#6d5a44';
            innerCtx.fillRect(0, 0, innerCanvas.width, innerCanvas.height);
            
            // Draw weave pattern for inner texture
            const innerWeaveSize = 4;
            innerCtx.globalAlpha = 1.0;
            
            for (let y = 0; y < innerCanvas.height; y += innerWeaveSize * 2) {
                for (let x = 0; x < innerCanvas.width; x += innerWeaveSize * 2) {
                    // Horizontal strands
                    innerCtx.fillStyle = '#5d4d38';
                    innerCtx.fillRect(x, y, innerWeaveSize * 2, innerWeaveSize);
                    
                    // Vertical strands
                    innerCtx.fillStyle = '#4d3d28';
                    innerCtx.fillRect(x, y + innerWeaveSize, innerWeaveSize, innerWeaveSize);
                    innerCtx.fillRect(x + innerWeaveSize, y, innerWeaveSize, innerWeaveSize);
                }
            }
            
            // Add texture noise
            innerCtx.globalAlpha = 0.15;
            for (let i = 0; i < 50000; i++) {
                const x = Math.floor(Math.random() * innerCanvas.width);
                const y = Math.floor(Math.random() * innerCanvas.height);
                
                innerCtx.fillStyle = Math.random() > 0.5 ? '#3d2d18' : '#5d4d38';
                innerCtx.fillRect(x, y, 1, 1);
            }
            
            innerCtx.globalAlpha = 1.0;
            
            const innerTexture = new THREE.CanvasTexture(innerCanvas);
            innerTexture.wrapS = THREE.RepeatWrapping;
            innerTexture.wrapT = THREE.RepeatWrapping;
            innerTexture.repeat.set(2, 1);
            
            return { basketTexture, innerTexture };
        }
        
        // Set up GUI controls
        function setupControls() {
            // Set up event listeners for all sliders
            document.getElementById('basketRadius').addEventListener('input', function(e) {
                params.basketRadius = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.basketRadius.toFixed(1);
                createBasket();
            });
            
            document.getElementById('basketHeight').addEventListener('input', function(e) {
                params.basketHeight = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.basketHeight.toFixed(1);
                createBasket();
            });
            
            document.getElementById('openingRatio').addEventListener('input', function(e) {
                params.openingRatio = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.openingRatio.toFixed(2);
                createBasket();
            });
            
            document.getElementById('wallThickness').addEventListener('input', function(e) {
                params.wallThickness = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.wallThickness.toFixed(2);
                createBasket();
            });
            
            document.getElementById('bottomCurve').addEventListener('input', function(e) {
                params.bottomCurve = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.bottomCurve.toFixed(2);
                createBasket();
            });
            
            document.getElementById('bottomBulge').addEventListener('input', function(e) {
                params.bottomBulge = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.bottomBulge.toFixed(2);
                createBasket();
            });
            
            document.getElementById('wallCurvature').addEventListener('input', function(e) {
                params.wallCurvature = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.wallCurvature.toFixed(2);
                createBasket();
            });
            
            document.getElementById('rimThickness').addEventListener('input', function(e) {
                params.rimThickness = parseFloat(e.target.value);
                this.nextElementSibling.textContent = params.rimThickness.toFixed(2);
                createBasket();
            });
            
            // Reset view button
            document.getElementById('resetView').addEventListener('click', function() {
                basketGroup.rotation.x = -0.2;
                basketGroup.rotation.y = 0;
                basketGroup.rotation.z = 0;
            });
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse controls for rotation
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', function(e) {
            isDragging = true;
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };
            
            basketGroup.rotation.y += deltaMove.x * 0.01;
            basketGroup.rotation.x += deltaMove.y * 0.01;
            
            basketGroup.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, basketGroup.rotation.x));
            
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });
        
        document.addEventListener('mouseup', function(e) {
            isDragging = false;
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isDragging) {
                basketGroup.rotation.y += 0.002;
            }
            
            renderer.render(scene, camera);
        }
        
        // Pattern Designer Implementation
        
        // Pattern Designer HTML
        const patternControlsHTML = `
        <div class="control-group" style="border-top: 1px solid #ccc; padding-top: 10px; margin-top: 20px;">
            <h3>Pattern Designer</h3>
            
            <div class="control-group">
                <label for="enablePattern">Enable Pattern</label>
                <input type="checkbox" id="enablePattern">
            </div>
            
            <div class="control-group">
                <label for="patternType">Pattern Type</label>
                <select id="patternType" style="width: 100%; padding: 5px;">
                    <option value="bands">Horizontal Bands</option>
                    <option value="spiral">Spiral</option>
                </select>
            </div>
            
            <div class="control-group bands-control">
                <label for="numBands">Number of Bands</label>
                <input type="range" id="numBands" min="1" max="8" step="1" value="4">
                <div class="value-display">4</div>
            </div>
            
            <div class="control-group bands-control">
                <label for="bandHeight">Band Height</label>
                <input type="range" id="bandHeight" min="50" max="200" step="5" value="85">
                <div class="value-display">85</div>
            </div>
            
            <div class="control-group bands-control">
                <label for="bandSpacing">Band Spacing</label>
                <input type="range" id="bandSpacing" min="80" max="200" step="5" value="130">
                <div class="value-display">130</div>
            </div>
            
            <div class="control-group bands-control">
                <label for="startY">Start Y Position (%)</label>
                <input type="range" id="startY" min="5" max="40" step="5" value="15">
                <div class="value-display">15%</div>
            </div>
            
            <div class="control-group spiral-control">
                <label for="spiralRotations">Spiral Rotations</label>
                <input type="range" id="spiralRotations" min="0.5" max="3" step="0.1" value="1.2">
                <div class="value-display">1.2</div>
            </div>
            
            <div class="control-group spiral-control">
                <label for="spiralHeight">Spiral Height (%)</label>
                <input type="range" id="spiralHeight" min="30" max="90" step="5" value="60">
                <div class="value-display">60%</div>
            </div>
            
            <div class="control-group spiral-control">
                <label for="spiralThickness">Spiral Thickness</label>
                <input type="range" id="spiralThickness" min="30" max="150" step="5" value="85">
                <div class="value-display">85</div>
            </div>
            
            <div class="control-group spiral-control">
                <label for="spiralOffset">Spiral Offset (°)</label>
                <input type="range" id="spiralOffset" min="0" max="360" step="10" value="0">
                <div class="value-display">0°</div>
            </div>
            
            <div class="control-group">
                <label for="numRepeats">Pattern Repeats</label>
                <input type="range" id="numRepeats" min="4" max="24" step="2" value="12">
                <div class="value-display">12</div>
            </div>
            
            <div class="control-group">
                <label for="trianglesPerRepeat">Triangles Per Repeat</label>
                <input type="range" id="trianglesPerRepeat" min="2" max="8" step="1" value="4">
                <div class="value-display">4</div>
            </div>
            
            <div class="control-group spiral-control">
                <label for="triangleHeight">Triangle Height</label>
                <input type="range" id="triangleHeight" min="30" max="150" step="5" value="85">
                <div class="value-display">85</div>
            </div>
            
            <div class="control-group">
                <label>Triangle Colors</label>
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <input type="color" id="color1" value="#362e25" style="width: 60px;">
                    <input type="color" id="color2" value="#9f8e78" style="width: 60px;">
                    <input type="color" id="color3" value="#4d3c2e" style="width: 60px;">
                    <input type="color" id="color4" value="#e0d5c0" style="width: 60px;">
                </div>
            </div>
            
            <button id="savePattern">Save Pattern</button>
            <button id="applyPattern">Apply Pattern</button>
            <div id="patternCode" style="display: none; margin-top: 10px; font-family: monospace; font-size: 10px; overflow: auto; max-height: 100px;"></div>
        </div>
        `;

        // Add this JavaScript code to setup the pattern designer
        function setupPatternDesigner() {
            // First add the HTML controls to the page
            document.getElementById('controls').insertAdjacentHTML('beforeend', patternControlsHTML);
            
            // Pattern parameters
            const patternParams = {
                enabled: false,
                numBands: 4,
                bandHeight: 85,
                bandSpacing: 130,
                startY: 15,
                numRepeats: 12,
                trianglesPerRepeat: 4,
                colors: ['#362e25', '#9f8e78', '#4d3c2e', '#e0d5c0'],
                patternType: 'bands', // Default pattern type
                spiralRotations: 1.2, // Number of rotations
                spiralHeight: 60, // Height of the spiral (%)
                spiralThickness: 85, // Thickness of the spiral band
                spiralOffset: 0, // Offset in degrees
                triangleHeight: 85 // Height of the triangles
            };
            
            // Setup event listeners for all pattern controls
            document.getElementById('enablePattern').addEventListener('change', function(e) {
                patternParams.enabled = e.target.checked;
                updateTexture();
            });
            
            document.getElementById('patternType').addEventListener('change', function(e) {
                patternParams.patternType = e.target.value;
                
                // Update the visibility of spiral controls
                const spiralControls = document.querySelectorAll('.spiral-control');
                const bandsControls = document.querySelectorAll('.bands-control');
                
                if (patternParams.patternType === 'spiral') {
                    spiralControls.forEach(control => control.style.display = 'block');
                    bandsControls.forEach(control => control.style.display = 'none');
                } else {
                    spiralControls.forEach(control => control.style.display = 'none');
                    bandsControls.forEach(control => control.style.display = 'block');
                }
                
                updateTexture();
            });
            
            document.getElementById('numBands').addEventListener('input', function(e) {
                patternParams.numBands = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.numBands;
                updateTexture();
            });
            
            document.getElementById('bandHeight').addEventListener('input', function(e) {
                patternParams.bandHeight = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.bandHeight;
                updateTexture();
            });
            
            document.getElementById('bandSpacing').addEventListener('input', function(e) {
                patternParams.bandSpacing = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.bandSpacing;
                updateTexture();
            });
            
            document.getElementById('startY').addEventListener('input', function(e) {
                patternParams.startY = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.startY + '%';
                updateTexture();
            });
            
            document.getElementById('spiralRotations').addEventListener('input', function(e) {
                patternParams.spiralRotations = parseFloat(e.target.value);
                this.nextElementSibling.textContent = patternParams.spiralRotations.toFixed(1);
                updateTexture();
            });
            
            document.getElementById('spiralHeight').addEventListener('input', function(e) {
                patternParams.spiralHeight = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.spiralHeight + '%';
                updateTexture();
            });
            
            document.getElementById('spiralThickness').addEventListener('input', function(e) {
                patternParams.spiralThickness = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.spiralThickness;
                updateTexture();
            });
            
            document.getElementById('spiralOffset').addEventListener('input', function(e) {
                patternParams.spiralOffset = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.spiralOffset + '°';
                updateTexture();
            });
            
            document.getElementById('triangleHeight').addEventListener('input', function(e) {
                patternParams.triangleHeight = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.triangleHeight;
                updateTexture();
            });
            
            document.getElementById('numRepeats').addEventListener('input', function(e) {
                patternParams.numRepeats = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.numRepeats;
                this.nextElementSibling.textContent = patternParams.numRepeats;
                updateTexture();
            });
            
            document.getElementById('trianglesPerRepeat').addEventListener('input', function(e) {
                patternParams.trianglesPerRepeat = parseInt(e.target.value);
                this.nextElementSibling.textContent = patternParams.trianglesPerRepeat;
                updateTexture();
            });
            
            // Color pickers
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`color${i}`).addEventListener('input', function(e) {
                    patternParams.colors[i-1] = e.target.value;
                    updateTexture();
                });
            }
            
            // Save button
            document.getElementById('savePattern').addEventListener('click', function() {
                const codeElement = document.getElementById('patternCode');
                codeElement.style.display = 'block';
                codeElement.textContent = JSON.stringify(patternParams, null, 2);
            });
            
            // Apply button
            document.getElementById('applyPattern').addEventListener('click', function() {
                updateTexture();
            });
            
            // Function to draw horizontal bands pattern
            // Modified drawBandsPattern function to match the exact pattern in the images
function drawBandsPattern(ctx, width, height, patternParams) {
    const numBands = patternParams.numBands;
    const bandHeight = patternParams.bandHeight;
    const bandSpacing = patternParams.bandSpacing;
    const startY = height * (patternParams.startY / 100);
    
    // Calculate the total width needed for 4 pattern repeats
    // Each repeat covers 1/4 of the circumference
    const patternRepeatWidth = width / 4;
    
    for (let band = 0; band < numBands; band++) {
        const bandY = startY + band * bandSpacing;
        
        // Draw pattern for specific band
        for (let repeat = 0; repeat < 4; repeat++) {
            const startX = repeat * patternRepeatWidth;
            
            // Draw specific pattern for each band
            drawBandPattern(ctx, startX, bandY, patternRepeatWidth, bandHeight, band, patternParams.colors);
        }
    }
}

// Function to draw the specific pattern for each band
function drawBandPattern(ctx, startX, startY, width, height, bandIndex, colors) {
    // Colors from the image
    const darkColor = colors[0];  // Dark brown/black
    const mediumColor = colors[2]; // Medium brown
    const lightColor = colors[1];  // Tan/beige (basket color)
    
    // Define number of triangles for this band
    const numTriangles = 12; // Adjust based on your basket pattern
    const triangleWidth = width / numTriangles;
    
    // Based on the images, each band has a different pattern
    // We'll define the pattern for each band
    let pattern;
    
    if (bandIndex % 4 === 0) {
        // First band pattern (top to bottom)
        pattern = [
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
        ];
    } else if (bandIndex % 4 === 1) {
        // Second band pattern
        pattern = [
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
        ];
    } else if (bandIndex % 4 === 2) {
        // Third band pattern
        pattern = [
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
        ];
    } else {
        // Fourth band pattern
        pattern = [
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            
            { color: mediumColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
            { color: darkColor, type: 'triangle' },
            { color: lightColor, type: 'triangle' },
        ];
    }
    
    // Draw the triangles based on the pattern
    for (let i = 0; i < pattern.length; i++) {
        const item = pattern[i];
        const tx = startX + i * triangleWidth;
        
        if (item.type === 'triangle') {
            // Draw triangle pointing down
            ctx.fillStyle = item.color;
            ctx.beginPath();
            ctx.moveTo(tx, startY);
            ctx.lineTo(tx + triangleWidth, startY);
            ctx.lineTo(tx + triangleWidth/2, startY + height);
            ctx.closePath();
            ctx.fill();
            
            // Add stroke to make the pattern more defined
            ctx.strokeStyle = '#2a2520';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }
}

// Initial pattern settings for the specific basket in the images
function getBasketPatternSettings() {
    return {
        enabled: true,
        patternType: 'bands',
        numBands: 4,
        bandHeight: 70, // Adjust to match image
        bandSpacing: 85, // Space between bands
        startY: 15,     // Starting position from top (%)
        numRepeats: 4,  // 4 repeats around the basket
        trianglesPerRepeat: 12,
        colors: [
            '#362e25',  // Dark brown/black
            '#e0d5c0',  // Light tan (basket color)
            '#9f7c55'   // Medium brown
        ]
    };
}

// Add this to your setup function to initialize with the correct pattern
function initWithCorrectPattern() {
    const patternParams = getBasketPatternSettings();
    document.getElementById('enablePattern').checked = patternParams.enabled;
    document.getElementById('patternType').value = patternParams.patternType;
    document.getElementById('numBands').value = patternParams.numBands;
    document.getElementById('bandHeight').value = patternParams.bandHeight;
    document.getElementById('bandSpacing').value = patternParams.bandSpacing;
    document.getElementById('startY').value = patternParams.startY;
    document.getElementById('numRepeats').value = patternParams.numRepeats;
    document.getElementById('trianglesPerRepeat').value = patternParams.trianglesPerRepeat;
    
    // Set the colors
    document.getElementById('color1').value = patternParams.colors[0];
    document.getElementById('color2').value = patternParams.colors[1];
    document.getElementById('color3').value = patternParams.colors[2];
    
    // Update all value displays
    document.getElementById('numBands').nextElementSibling.textContent = patternParams.numBands;
    document.getElementById('bandHeight').nextElementSibling.textContent = patternParams.bandHeight;
    document.getElementById('bandSpacing').nextElementSibling.textContent = patternParams.bandSpacing;
    document.getElementById('startY').nextElementSibling.textContent = patternParams.startY + '%';
    document.getElementById('numRepeats').nextElementSibling.textContent = patternParams.numRepeats;
    document.getElementById('trianglesPerRepeat').nextElementSibling.textContent = patternParams.trianglesPerRepeat;
    
    // Update visibility of controls
    const spiralControls = document.querySelectorAll('.spiral-control');
    const bandsControls = document.querySelectorAll('.bands-control');
    
    if (patternParams.patternType === 'spiral') {
        spiralControls.forEach(control => control.style.display = 'block');
        bandsControls.forEach(control => control.style.display = 'none');
    } else {
        spiralControls.forEach(control => control.style.display = 'none');
        bandsControls.forEach(control => control.style.display = 'block');
    }
    
    // Apply the pattern
    window.createTextures = function() {
        return window.createTexturesWithPattern(patternParams);
    };
    
    // Recreate the basket with the new texture
    createBasket();
}
            
            // Function to draw spiral pattern
            function drawSpiralPattern(ctx, width, height, patternParams) {
                const centerX = width / 2;
                const centerY = height / 2;
                const spiralRotations = patternParams.spiralRotations; // Number of rotations
                const spiralHeight = height * (patternParams.spiralHeight / 100); // Height of the spiral pattern
                const spiralThickness = patternParams.spiralThickness; // Thickness of the spiral band
                const triangleHeight = patternParams.triangleHeight; // Height of the triangles
                const spiralOffset = patternParams.spiralOffset * (Math.PI / 180); // Offset in radians
                
                // Calculate the start and end Y positions for the spiral
                const startY = centerY - (spiralHeight / 2);
                const endY = centerY + (spiralHeight / 2);
                
                // Number of triangles around the spiral
                const numTriangles = patternParams.numRepeats * spiralRotations;
                
                // Draw the triangles along the spiral
                for (let i = 0; i <= numTriangles; i++) {
                    // Calculate the angle and radius for this point
                    const angle = (i / numTriangles) * Math.PI * 2 * spiralRotations + spiralOffset;
                    
                    // Calculate the y position (vertical position along the spiral)
                    const progress = i / numTriangles;
                    const y = startY + progress * (endY - startY);
                    
                    // Calculate the x position based on angle
                    const x = centerX + Math.cos(angle) * (width / 3);
                    
                    // Calculate the triangle width based on the distance from adjacent points
                    const nextAngle = ((i + 1) / numTriangles) * Math.PI * 2 * spiralRotations + spiralOffset;
                    const nextX = centerX + Math.cos(nextAngle) * (width / 3);
                    const nextY = startY + ((i + 1) / numTriangles) * (endY - startY);
                    
                    // Calculate distance between current and next point
                    const distance = Math.sqrt(Math.pow(nextX - x, 2) + Math.pow(nextY - y, 2));
                    const triangleWidth = distance * 0.9; // Slightly less than full distance
                    
                    // Determine triangle color based on position
                    let triangleColor;
                    if (i % patternParams.trianglesPerRepeat === 0) {
                        triangleColor = patternParams.colors[0];
                    } else if (i % patternParams.trianglesPerRepeat === 1) {
                        triangleColor = patternParams.colors[1];
                    } else if (i % patternParams.trianglesPerRepeat === 2) {
                        triangleColor = patternParams.colors[2];
                    } else {
                        triangleColor = patternParams.colors[3];
                    }
                    
                    // Calculate direction vector for the triangle
                    const dirX = nextX - x;
                    const dirY = nextY - y;
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    const normDirX = dirX / length;
                    const normDirY = dirY / length;
                    
                    // Calculate perpendicular direction for triangle height
                    const perpDirX = -normDirY;
                    const perpDirY = normDirX;
                    
                    // Triangle points
                    const p1x = x;
                    const p1y = y;
                    const p2x = nextX;
                    const p2y = nextY;
                    const p3x = (x + nextX) / 2 + perpDirX * triangleHeight;
                    const p3y = (y + nextY) / 2 + perpDirY * triangleHeight;
                    
                    // Draw triangle
                    ctx.fillStyle = triangleColor;
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.lineTo(p3x, p3y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add stroke
                    ctx.strokeStyle = '#2a2520';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
            
            // Modified createTextures function to support patterns
            window.createTexturesWithPattern = function(patternParams) {
                // Create canvas for outer texture
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 1024;
                canvas.height = 1024;
                
                // Fill with base color (light beige/tan)
                ctx.fillStyle = '#e0d5c0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw detailed weave texture
                const weaveSize = 4;
                ctx.globalAlpha = 1.0;
                
                // Create horizontal strands
                for (let y = 0; y < canvas.height; y += weaveSize * 2) {
                    for (let x = 0; x < canvas.width; x += weaveSize) {
                        // Alternate colors for horizontal strands
                        ctx.fillStyle = (Math.floor(y / (weaveSize * 2)) % 2 === 0) ? '#d4c9b4' : '#c9bea9';
                        ctx.fillRect(x, y, weaveSize, weaveSize);
                        
                        // Add subtle shading for dimension
                        ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        ctx.fillRect(x, y + weaveSize - 1, weaveSize, 1);
                    }
                }
                
                // Create vertical strands (going over and under)
                for (let x = 0; x < canvas.width; x += weaveSize * 2) {
                    for (let y = 0; y < canvas.height; y += weaveSize * 2) {
                        // First vertical strand
                        ctx.fillStyle = (Math.floor(x / (weaveSize * 2)) % 2 === 0) ? '#b5a89e' : '#a89c92';
                        ctx.fillRect(x, y + weaveSize, weaveSize, weaveSize);
                        
                        // Second vertical strand
                        ctx.fillRect(x + weaveSize, y, weaveSize, weaveSize);
                        
                        // Add subtle shading for dimension
                        ctx.fillStyle = 'rgba(0,0,0,0.15)';
                        ctx.fillRect(x + weaveSize - 1, y, 1, weaveSize);
                        ctx.fillRect(x + weaveSize * 2 - 1, y + weaveSize, 1, weaveSize);
                    }
                }
                
                // Add texture noise for realism
                ctx.globalAlpha = 0.1;
                for (let i = 0; i < 80000; i++) {
                    const x = Math.floor(Math.random() * canvas.width);
                    const y = Math.floor(Math.random() * canvas.height);
                    
                    ctx.fillStyle = Math.random() > 0.5 ? '#857b70' : '#c9bea9';
                    ctx.fillRect(x, y, 1, 1);
                }
                
                ctx.globalAlpha = 1.0;
                
                // Add geometric pattern if enabled
                if (patternParams.enabled) {
                    if (patternParams.patternType === 'spiral') {
                        // Draw spiral pattern
                        drawSpiralPattern(ctx, canvas.width, canvas.height, patternParams);
                    } else {
                        // Draw horizontal bands pattern
                        drawBandsPattern(ctx, canvas.width, canvas.height, patternParams);
                    }
                }
                
                // Create texture from canvas
                const basketTexture = new THREE.CanvasTexture(canvas);
                basketTexture.wrapS = THREE.RepeatWrapping;
                basketTexture.wrapT = THREE.RepeatWrapping;
                basketTexture.repeat.set(2, 1);
                
                // Create inner texture - similar but darker
                const innerCanvas = document.createElement('canvas');
                const innerCtx = innerCanvas.getContext('2d');
                innerCanvas.width = 1024;
                innerCanvas.height = 1024;
                
                innerCtx.fillStyle = '#6d5a44';
                innerCtx.fillRect(0, 0, innerCanvas.width, innerCanvas.height);
                
                // Draw weave pattern for inner texture
                const innerWeaveSize = 4;
                innerCtx.globalAlpha = 1.0;
                
                for (let y = 0; y < innerCanvas.height; y += innerWeaveSize * 2) {
                    for (let x = 0; x < innerCanvas.width; x += innerWeaveSize * 2) {
                        // Horizontal strands
                        innerCtx.fillStyle = '#5d4d38';
                        innerCtx.fillRect(x, y, innerWeaveSize * 2, innerWeaveSize);
                        
                        // Vertical strands
                        innerCtx.fillStyle = '#4d3d28';
                        innerCtx.fillRect(x, y + innerWeaveSize, innerWeaveSize, innerWeaveSize);
                        innerCtx.fillRect(x + innerWeaveSize, y, innerWeaveSize, innerWeaveSize);
                    }
                }
                
                // Add texture noise
                innerCtx.globalAlpha = 0.15;
                for (let i = 0; i < 50000; i++) {
                    const x = Math.floor(Math.random() * innerCanvas.width);
                    const y = Math.floor(Math.random() * innerCanvas.height);
                    
                    innerCtx.fillStyle = Math.random() > 0.5 ? '#3d2d18' : '#5d4d38';
                    innerCtx.fillRect(x, y, 1, 1);
                }
                
                innerCtx.globalAlpha = 1.0;
                
                const innerTexture = new THREE.CanvasTexture(innerCanvas);
                innerTexture.wrapS = THREE.RepeatWrapping;
                innerTexture.wrapT = THREE.RepeatWrapping;
                innerTexture.repeat.set(2, 1);
                
                return { basketTexture, innerTexture };
            };
            
            // Update the texture using the current pattern parameters
            function updateTexture() {
                // Update the visibility of spiral controls
                const spiralControls = document.querySelectorAll('.spiral-control');
                const bandsControls = document.querySelectorAll('.bands-control');
                
                if (patternParams.patternType === 'spiral') {
                    spiralControls.forEach(control => control.style.display = 'block');
                    bandsControls.forEach(control => control.style.display = 'none');
                } else {
                    spiralControls.forEach(control => control.style.display = 'none');
                    bandsControls.forEach(control => control.style.display = 'block');
                }
                
                // Override the original createTextures function
                window.createTextures = function() {
                    return window.createTexturesWithPattern(patternParams);
                };
                
                // Recreate the basket with the new texture
                createBasket();
            }
            
            // Initially hide spiral controls
            document.querySelectorAll('.spiral-control').forEach(control => {
                control.style.display = 'none';
            });
            
            // Initialize with pattern matching the reference basket
            initWithCorrectPattern();
        }

        // Add this function call to the initialization
        function initWithPatternDesigner() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 7;
            camera.position.y = 1;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-1, 0.5, -1);
            scene.add(directionalLight2);
            
            // Create basket
            basketGroup = new THREE.Group();
            scene.add(basketGroup);
            
            createBasket();
            
            // Set up event listeners
            window.addEventListener('resize', onWindowResize);
            setupControls();
            setupPatternDesigner();
            
            // Start animation
            animate();
        }

        // Replace the init() function call with initWithPatternDesigner()
        // init();  // <-- comment out this line
        initWithPatternDesigner();  // <-- add this line instead
        
    </script>
</body>
</html>